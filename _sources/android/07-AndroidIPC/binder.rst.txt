07-AndroidIPC - Binder 
==================================
There are several techniques to achieve Inter-process communication like sockets, signals, pipes, message queues, semaphores, shared memory, etc. IPC communication can be acheived in Android using Binder Framework through AIDL and HIDL. Binder is an Android-specific IPC mechanism, which enables an RPC (remote procedure call) mechanism between the client and server processes. Client process can execute remote methods in the server process as if they were executed locally.

Android supports 3 IPC domains

+----------------+--------------------------------------------------------------------------------+
| /dev/binder    | IPC between framework/app processes with AIDL interfaces.                      |
+----------------+--------------------------------------------------------------------------------+
| /dev/hwbinder  | | IPC between framework/vendor processes with HIDL interfaces.                 |
|                | | IPC between vendor processes with AIDL/HIDL interfaces                       |
+----------------+--------------------------------------------------------------------------------+
| /dev/vndbinder | IPC between framework/app processes with AIDL interfaces.                      |
+----------------+--------------------------------------------------------------------------------+

From Android 8, the "/dev/binder" device node is designated as exclusive node of the framework process, which means that the vendor process can no longer access this node. Vendor processes can access "/dev/hwbinder" and use HIDL. However from Android 10, AIDL is being recommended instead of HIDL, since HIDL is soon to be deprecated.

dev/binder
~~~~~~~~~~~~~~~
This is the most common binder that is widely used. This acts as communication interface between App/Framework Processes or Services. On the implementation of Binder, Java inherits Binder Class and C++ inherits Bbbinder class.

dev/vndbinder
~~~~~~~~~~~~~~~
This binder is used as communication interface between vendor processes. Just like binder implementation, Java inherits Binder and C++ inherits Bbbinder. vndbinder is registered through the vndservicemanager process, and then the anonymous Binder object is passed through the Binder interface that has been created After getting BinderProxy or BpBinder.

dev/hwbinder
~~~~~~~~~~~~~~~
This binder is used as communication interface between vendor processes with Frameworks. Usually the Vendor BSP consists of hardware driver which needs to be interfaced with Android Frameworks. This is done through hwbinder.

Binder Communication
-----------------------

.. figure:: binder.png
   :scale: 100 %

Binder Communication Flow
---------------------------

.. figure:: bindercall.png
   :scale: 100 %

Brief
--------
A process cannot access another process’s memory, however kernel has control over all processes and therefore can expose an interface that enables IPC. Binder interface /dev/binder device, is implemented by the Binder kernel driver. All the IPC calls go through Binder kernel driver.

The Binder driver manages part of the address space of each process. The Binder driver-managed chunk of memory is read-only to the process, and all writing is performed by the kernel module. When a process sends a message to another process, the kernel allocates some space in the destination process’s memory and copies the message data directly from the sending process. It then queues a short message to the receiving process telling it where the received message is. The recipient can then access that message directly (because it is in its own memory space).

Higher-level IPC abstractions in Android such as Intents and ContentProviders are some of the components that are built on top of Binder. Service interfaces that need to be exposed to other processes can be defined using the Android Interface Definition Language (AIDL), which enables clients to call remote services as if they were local Java objects.

Binder Tokens
~~~~~~~~~~~~~~~
Binder object instance maintains a unique identity across all processes in the system. Binder kernel driver allocates unique ID for each instance, making Binders unique. The application framework uses Binder tokens extensively in order to ensure secure interaction between cooperating processes. A client can create a Binder object to use as a token that can be shared with a server process, and the server can use it to validate the client’s requests without there being any way for others to sniff the communication exchange.

Reference Counting
~~~~~~~~~~~~~~~~~~~~
Reference counting guarantees that Binder objects are automatically freed when no one references them. The binder kernel driver remembers a new object reference whenever a transaction happens. When a transaction occurs the reference count to that particular binder object is incremented. When a process dies, the reference count is automatically decremented. When a reference is no longer needed, its owner is notified and that binder object is released and removed from binder mapping.

Link-To-Death or Death Recipient
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Binder’s “link-to-death” facility, allows a process to get a callback when another process hosting a binder object is freed or killed. The client can receive a callback when a Service dies. The callback is usually used to execute cleanup codes when death notification is received.

ServiceManager
~~~~~~~~~~~~~~~~~
The ServiceManager is the main process, which manages all the services of the system. It provides the functionality to register and find the corresponding services. ServiceManager works directly with the binder driver for required IPC.

Reference:
------------
[1]: ``https://mymusing.co/what-is-binder-in-android/``

[2]: ``https://developpaper.com/a-simple-example-of-binder/``

[3]: ``https://medium.com/android-news/android-binder-framework-8a28fb38699a``

[4]: ``https://www.androiddesignpatterns.com/2013/07/binders-window-tokens.html``

[5]: ``https://proandroiddev.com/binders-in-android-part-ii-reference-counting-death-recipients-19d55c8356c3``



 

 
